<!DOCTYPE html>

<html lang="en">
<head>
	<title>Puzzle Generator</title>
	<meta charset="utf-8">
	<meta name="description" content="Jigsaw Puzzle Generator">
	<meta name="author" content="Jacob Valore">
	<script src="./scripts/jquery-3.3.1-min.js"></script>
	<script src="./scripts/pds-generator-min.js"></script>
	<script src="./scripts/catmull-rom.js"></script>
	<script src="./scripts/voronoi-min.js"></script>
	<link rel="stylesheet" href="./style.css">
</head>

<body>
	<div class="content">
		<div class="sidebar-left">
			<div class="input-container">
				<div class="label">Width:</div>
				<input class="small-textbox tb-width" type="text" value=500>
			</div>
			<div class="input-container">
				<div class="label">Height:</div>
				<input class="small-textbox tb-height" type="text" value=300>
			</div>
			<div class="input-container">
				<div class="label">Min-Distance:</div>
				<input class="small-textbox tb-min-distance" type="text" value=30>
			</div>
			<div class="input-container">
				<div class="label">Max-Jitter</div>
				<input class="small-textbox tb-max-jitter" type="text" value=10>
			</div>
			<input class="button" type="submit" value="Generate Voronoi" onclick="gen_voronoi()">
			<input class="button" type="submit" value="Generate Radial" onclick="gen_radial()">
			<input class="button" type="submit" value="Generate Grid" onclick="gen_grid()">
		</div>
		<div class="main-content">
			<div class="puzzle-container">

			</div>
		</div>
	</div>
</body>
<script>
	var vals = {width: +$('.tb-width').val(),
				height: +$('.tb-height').val(),
				min_dist: +$('.tb-min-distance').val(),
				max_jitter: +$('.tb-max-jitter').val()};
	build_svg();
	// Generation functions
	function gen_voronoi(usePDS = true, nSites = 20, minDist = 100, maxDist = 200){
		vals.lines = [];
		if(usePDS){
			// Generate sites with PDS (doesn't use nSites)
			var pds2D = new PoissonDiskSampling({
				shape: [vals.width, vals.height],
				minDistance: minDist,
				maxDistance: maxDist
			});
			var sites = pds2D.fill();
			for(var i = 0; i < sites.length; i++)
				sites[i] = {x: sites[i][0], y: sites[i][1]};
		} else {
			// Or generate sites with regular randomness (doesn't use min/max distance)
			var sites = [];
			for(var i = 0; i < nSites; i++)
				sites.push({x: vals.width*Math.random(), y: vals.height*Math.random()});
		}
		var voro = new Voronoi();
		var bbox = {xl: 0, xr: vals.width, yt: 0, yb: vals.height};
		var diagram = voro.compute(sites, bbox);
		for(var i = 0; i < diagram.edges.length; i++)
			vals.lines.push('M'+diagram.edges[i].va.x+','+diagram.edges[i].va.y+' L'+diagram.edges[i].vb.x+','+diagram.edges[i].vb.y);
		build_svg();
	}
	function gen_radial(){
		// Start the circle somewhere out on the x axis
		// Transform it with a rotation
		// Then transform it to the center of the voronoi shape
		vals.lines = [];
		vals.points = [];
		var cx = Math.random()*Math.max(vals.width,vals.height)*2, cy = 0;
		var ringMax = Math.ceil( ((cx**2 + vals.height**2)**0.5) / vals.min_dist )+15;
		for(var i = Math.max(1,ringMax-30); i < ringMax; i++){ //i affects the radius
			var points_str = '';
			var nPoints = Math.floor(6.28*i);
			for(var j = 0; j < nPoints; j++){ //j affects the angle
				var x_jitter = vals.max_jitter*(Math.random()-0.5);
				var y_jitter = vals.max_jitter*(Math.random()-0.5);
				points_str += (cx+i*vals.min_dist*Math.cos(j*6.28/nPoints)+x_jitter) + ',';
				points_str += (cy+i*vals.min_dist*Math.sin(j*6.28/nPoints)+y_jitter) + ' ';
				vals.points.push([cx+i*vals.min_dist*Math.cos(j*6.28/nPoints)+x_jitter,
									cy+i*vals.min_dist*Math.sin(j*6.28/nPoints)+y_jitter]);
			}
			points_str += (cx+i*vals.min_dist)+','+cy;
			//TODO: Fix catmull so the circle connects back smoothly
			vals.lines.push('M'+(cx+i*vals.min_dist)+','+cy+' '+catmullRom2bezier(points_str));
		}
		build_svg();
	}
	function gen_grid(){
		// Transform it with just a rotation
		vals.lines = [];
		vals.points = [];

		var nPoints = Math.ceil( ((vals.width**2 + vals.height**2)**0.5) / vals.min_dist )+1;
		var x_center = vals.width/2, y_center = vals.height/2, half_grid_size = (nPoints-1)*vals.min_dist/2;
		var x_start = x_center-half_grid_size, y_start = y_center-half_grid_size;

		for(var i = 0; i < nPoints; i++){
			var points_str = '';
			for(var j = 0; j < nPoints; j++){
				var x_jitter = vals.max_jitter*(Math.random()-0.5);
				var y_jitter = vals.max_jitter*(Math.random()-0.5);
				points_str += (x_start+i*vals.min_dist+x_jitter) + ',';
				points_str += (y_start+j*vals.min_dist+y_jitter) + ' ';
				vals.points.push([x_start+i*vals.min_dist+x_jitter,
									y_start+j*vals.min_dist+y_jitter]);
			}
			vals.lines.push('M'+(x_start+i*vals.min_dist)+','+(y_start)+' '+catmullRom2bezier(points_str));
		}
		build_svg();
	}
	/* TODO:
	 *	2. Add variation to gen_radial()
	 *	3. Make new functions for them that just return the lines
	 *	4. Change build_svg() to make a group with a mask of the voronoi cell
	 *	5. Make new button to put all of that together
	*/
	// Helper functions
	function build_svg(){
		var svg = '';
		if(vals.width && vals.height){
			svg = '';
			svg += '<svg version="1.1" viewbox="0 0 '+vals.width+' '+vals.height+'" class="puzzle" xmlns="http://www.w3.org/2000/svg">';
			svg += '<style>';
			svg += '.outline{ fill: none; stroke: black; stroke-width: 2; }';
			svg += '.point{ fill: black; stroke: none; }';
			svg += '</style>';
			svg += '<rect class="outline" width="100%" height="100%"/>';
			if(vals.lines){
				for(var i = 0; i < vals.lines.length; i++){
					svg += '<path class="outline" d="'+vals.lines[i]+'"/>';
				}
			}
			if(vals.points){
				for(var i = 0; i < vals.points.length; i++){
					svg += '<circle class="point" cx="'+vals.points[i][0]+'" cy="'+vals.points[i][1]+'" r="2"/>';
				}
			}
			svg += '</svg>';
		}
		$('.puzzle-container').html(svg);
	}
	// Update the variables in vals
	$('.tb-width').on('focusout', function() {
		vals.width = +this.value;
		build_svg();
	});
	$('.tb-height').on('focusout', function() {
		vals.height = +this.value;
		build_svg();
	});
	$('.tb-min-distance').on('focusout', function() {
		vals.min_dist = +this.value;
	});
	$('.tb-max-jitter').on('focusout', function() {
		vals.max_jitter = +this.value;
	});
	// Focusout when enter is pressed
	$('.small-textbox').keypress(function(e) {
		if(e.which == 13)
			$(this).blur();
	});
	// Deprecated
	function gen_center_points(){
		// Create point generator
		var pds2D = new PoissonDiskSampling({
			shape: [vals.width, vals.height],
			minDistance: vals.min_dist,
			maxDistance: vals.max_dist,
			tries: 100000
		});
		// Add edge points as constraints
		for(var i = 0; i < vals.points.length; i++){
			pds2D.addPoint([vals.points[i][0], vals.points[i][1]]);
		}
		// Generate the center points
		vals.points = pds2D.fill();
		console.log(vals.points);
	}
</script>
